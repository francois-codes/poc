<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RxDB NATS Replication Frontend</title>
    <script src="https://unpkg.com/rxdb/plugins/replication-nats.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .user-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            background: white;
        }
        .user-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #eee;
        }
        .user-item:last-child { border-bottom: none; }
        .user-info { flex: 1; }
        .user-email { font-weight: bold; color: #333; }
        .user-meta { font-size: 12px; color: #666; margin-top: 4px; }
        .form-group { margin: 10px 0; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: bold; }
        .form-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }
        .logs {
            background: #1e1e1e;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        .log-entry { margin: 2px 0; word-wrap: break-word; }
        h1 { color: #007bff; text-align: center; }
        h3 { margin-top: 0; color: #495057; }
        .stats { display: flex; gap: 20px; margin-top: 10px; }
        .stat-item {
            background: white;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            text-align: center;
        }
        .stat-value { font-size: 24px; font-weight: bold; color: #007bff; }
        .stat-label { font-size: 12px; color: #666; }
    </style>
</head>
<body>
    <h1>üöÄ RxDB NATS Replication Frontend</h1>
    
    <div class="container">
        <h3>üîÑ RxDB NATS Replication Status</h3>
        <div id="replicationStatus" class="status info">Initializing RxDB...</div>
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="localCount">0</div>
                <div class="stat-label">Local Users</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="syncedCount">0</div>
                <div class="stat-label">Synced Docs</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="errorCount">0</div>
                <div class="stat-label">Errors</div>
            </div>
        </div>
        <button id="startReplication" onclick="startReplication()">üîÑ Start NATS Replication</button>
        <button id="stopReplication" onclick="stopReplication()" disabled>‚èπÔ∏è Stop Replication</button>
    </div>

    <div class="container">
        <h3>üë§ User Management</h3>
        <div class="form-group">
            <label>Email:</label>
            <input type="email" id="userEmail" placeholder="user@example.com">
        </div>
        <div class="form-group">
            <label>Status:</label>
            <input type="text" id="userStatus" placeholder="active" value="active">
        </div>
        <div class="form-group">
            <label>Role:</label>
            <input type="text" id="userRole" placeholder="user" value="user">
        </div>
        <button onclick="createUser()">‚ûï Create User</button>
        <button onclick="updateRandomUser()">üîÑ Update Random User</button>
        <button onclick="deleteRandomUser()">üóëÔ∏è Delete Random User</button>
    </div>

    <div class="container">
        <h3>üíæ Local Users (RxDB + NATS)</h3>
        <div id="localUsers" class="user-list">
            <div class="user-item">No users yet...</div>
        </div>
        <button onclick="clearLocalUsers()">üßπ Clear All Local Users</button>
        <button onclick="refreshDisplay()">üîÑ Refresh Display</button>
    </div>

    <div class="container">
        <h3>üì° Replication Logs</h3>
        <div id="logs" class="logs">
            <div class="log-entry">üé¨ RxDB NATS Replication Frontend Starting...</div>
        </div>
        <button onclick="clearLogs()">üßπ Clear Logs</button>
    </div>

    <!-- Import RxDB core via CDN -->
    <script src="https://unpkg.com/rxdb@15.34.1/dist/rxdb.min.js"></script>
    <script type="module">

        // Global variables
        let database = null;
        let usersCollection = null;
        let replicationState = null;
        let syncedCount = 0;
        let errorCount = 0;

        // Make functions available globally
        window.startReplication = startReplication;
        window.stopReplication = stopReplication;
        window.createUser = createUser;
        window.updateRandomUser = updateRandomUser;
        window.deleteRandomUser = deleteRandomUser;
        window.clearLocalUsers = clearLocalUsers;
        window.refreshDisplay = refreshDisplay;
        window.clearLogs = clearLogs;

        // Initialize RxDB
        async function initRxDB() {
            try {
                logMessage('üîß Creating RxDB database...');
                
                database = await RxDB.createRxDatabase({
                    name: 'usersdb_nats',
                    storage: RxDB.getRxStorageIndexedDB(),
                    multiInstance: true,
                    ignoreDuplicate: true
                });

                const userSchema = {
                    version: 0,
                    primaryKey: 'id',
                    type: 'object',
                    properties: {
                        id: { type: 'string', primary: true },
                        email: { type: 'string' },
                        status: { type: 'string' },
                        role: { type: 'string' },
                        created_at: { type: 'string' },
                        updated_at: { type: 'string' },
                        _deleted: { type: 'boolean' }
                    },
                    required: ['id', 'email', 'status']
                };

                usersCollection = await database.addCollections({
                    users: { schema: userSchema }
                });

                // Set up reactive UI updates
                usersCollection.users.find()
                    .where('_deleted').ne(true)
                    .$.subscribe(users => {
                        displayUsers(users);
                        updateStats();
                    });

                updateReplicationStatus('‚úÖ RxDB initialized successfully', 'success');
                logMessage('‚úÖ RxDB database and collection created');
                
            } catch (error) {
                console.error('RxDB initialization failed:', error);
                logMessage('‚ùå RxDB initialization failed: ' + error.message);
                updateReplicationStatus('Failed to initialize RxDB: ' + error.message, 'error');
                errorCount++;
                updateStats();
            }
        }

        // Start NATS replication
        async function startReplication() {
            try {
                updateReplicationStatus('Starting NATS replication...', 'info');
                logMessage('üîÑ Starting RxDB NATS replication...');

                replicationState = RxDB.replicateNats({
                    collection: usersCollection.users,
                    replicationIdentifier: 'users-replication',
                    streamName: 'USERS_BROADCAST',
                    subjectPrefix: 'users',
                    connection: { servers: 'localhost:4222' },
                    live: true,
                    pull: { batchSize: 30 },
                    push: { batchSize: 30 }
                });

                // Set up event listeners
                replicationState.error$.subscribe(error => {
                    console.error('Replication error:', error);
                    errorCount++;
                    logMessage('‚ùå Replication error: ' + error.message);
                    updateStats();
                });

                replicationState.active$.subscribe(active => {
                    logMessage(active ? 'üü¢ Replication is active' : 'üî¥ Replication is inactive');
                });

                replicationState.sent$.subscribe(sent => {
                    syncedCount++;
                    logMessage('üì§ Document sent to NATS: ' + sent.id);
                    updateStats();
                });

                replicationState.received$.subscribe(received => {
                    syncedCount++;
                    logMessage('üì• Document received from NATS: ' + received.id);
                    updateStats();
                });

                // Wait for initial replication
                await replicationState.awaitInitialReplication();

                updateReplicationStatus('‚úÖ NATS replication is active!', 'success');
                logMessage('‚úÖ NATS replication started successfully');
                
                document.getElementById('startReplication').disabled = true;
                document.getElementById('stopReplication').disabled = false;

            } catch (error) {
                console.error('Failed to start replication:', error);
                logMessage('‚ùå Failed to start NATS replication: ' + error.message);
                updateReplicationStatus('Failed to start replication: ' + error.message, 'error');
                errorCount++;
                updateStats();
            }
        }

        // Stop NATS replication
        async function stopReplication() {
            try {
                if (replicationState) {
                    await replicationState.cancel();
                    replicationState = null;
                }
                
                updateReplicationStatus('Replication stopped', 'info');
                logMessage('‚èπÔ∏è NATS replication stopped');
                
                document.getElementById('startReplication').disabled = false;
                document.getElementById('stopReplication').disabled = true;
                
            } catch (error) {
                console.error('Failed to stop replication:', error);
                logMessage('‚ùå Failed to stop replication: ' + error.message);
                errorCount++;
                updateStats();
            }
        }

        // Create a new user
        async function createUser() {
            try {
                const email = document.getElementById('userEmail').value;
                const status = document.getElementById('userStatus').value;
                const role = document.getElementById('userRole').value;

                if (!email || !status) {
                    alert('Email and status are required!');
                    return;
                }

                logMessage('üë§ Creating user in RxDB...');

                const userDoc = {
                    id: generateUUID(),
                    email: email,
                    status: status,
                    role: role || 'user',
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                    _deleted: false
                };

                await usersCollection.users.insert(userDoc);
                
                logMessage('‚úÖ User created: ' + email);

                // Clear form
                document.getElementById('userEmail').value = '';
                document.getElementById('userStatus').value = 'active';
                document.getElementById('userRole').value = 'user';

            } catch (error) {
                console.error('Failed to create user:', error);
                logMessage('‚ùå Failed to create user: ' + error.message);
                errorCount++;
                updateStats();
            }
        }

        // Update a random user
        async function updateRandomUser() {
            try {
                const users = await usersCollection.users.find()
                    .where('_deleted').ne(true)
                    .exec();
                    
                if (users.length === 0) {
                    alert('No users to update. Create a user first!');
                    return;
                }

                const randomUser = users[Math.floor(Math.random() * users.length)];
                const newEmail = `updated-${Date.now()}@example.com`;
                const newStatus = Math.random() > 0.5 ? 'active' : 'inactive';
                const newRole = Math.random() > 0.5 ? 'admin' : 'user';

                logMessage(`üîÑ Updating user ${randomUser.email}...`);

                await randomUser.update({
                    $set: {
                        email: newEmail,
                        status: newStatus,
                        role: newRole,
                        updated_at: new Date().toISOString()
                    }
                });

                logMessage('‚úÖ User updated: ' + newEmail);

            } catch (error) {
                console.error('Failed to update user:', error);
                logMessage('‚ùå Failed to update user: ' + error.message);
                errorCount++;
                updateStats();
            }
        }

        // Delete a random user (soft delete)
        async function deleteRandomUser() {
            try {
                const users = await usersCollection.users.find()
                    .where('_deleted').ne(true)
                    .exec();
                    
                if (users.length === 0) {
                    alert('No users to delete. Create a user first!');
                    return;
                }

                const randomUser = users[Math.floor(Math.random() * users.length)];
                
                logMessage(`üóëÔ∏è Deleting user ${randomUser.email}...`);

                await randomUser.update({
                    $set: {
                        _deleted: true,
                        updated_at: new Date().toISOString()
                    }
                });

                logMessage('‚úÖ User deleted: ' + randomUser.email);

            } catch (error) {
                console.error('Failed to delete user:', error);
                logMessage('‚ùå Failed to delete user: ' + error.message);
                errorCount++;
                updateStats();
            }
        }

        // Clear all local users
        async function clearLocalUsers() {
            try {
                if (confirm('Are you sure you want to delete all local users?')) {
                    const users = await usersCollection.users.find()
                        .where('_deleted').ne(true)
                        .exec();
                    
                    for (const user of users) {
                        await user.update({
                            $set: {
                                _deleted: true,
                                updated_at: new Date().toISOString()
                            }
                        });
                    }
                    
                    logMessage('üßπ All local users marked as deleted');
                }
            } catch (error) {
                console.error('Failed to clear users:', error);
                logMessage('‚ùå Failed to clear users: ' + error.message);
                errorCount++;
                updateStats();
            }
        }

        // Display users in UI
        function displayUsers(users) {
            const container = document.getElementById('localUsers');
            
            if (users.length === 0) {
                container.innerHTML = '<div class="user-item">No users yet...</div>';
                return;
            }

            container.innerHTML = users.map(user => `
                <div class="user-item">
                    <div class="user-info">
                        <div class="user-email">${user.email}</div>
                        <div class="user-meta">ID: ${user.id.substring(0, 8)}... | Status: ${user.status} | Role: ${user.role}</div>
                    </div>
                </div>
            `).join('');
        }

        // Refresh display
        async function refreshDisplay() {
            try {
                const users = await usersCollection.users.find()
                    .where('_deleted').ne(true)
                    .exec();
                displayUsers(users);
                updateStats();
                logMessage(`üìä Refreshed display: ${users.length} users`);
            } catch (error) {
                console.error('Failed to refresh display:', error);
                logMessage('‚ùå Failed to refresh display: ' + error.message);
            }
        }

        // Update statistics
        function updateStats() {
            if (usersCollection) {
                usersCollection.users.find()
                    .where('_deleted').ne(true)
                    .exec()
                    .then(users => {
                        document.getElementById('localCount').textContent = users.length;
                    });
            }
            document.getElementById('syncedCount').textContent = syncedCount;
            document.getElementById('errorCount').textContent = errorCount;
        }

        // Update replication status
        function updateReplicationStatus(message, type) {
            const status = document.getElementById('replicationStatus');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        // Utility functions
        function logMessage(message) {
            const logs = document.getElementById('logs');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = `[${timestamp}] ${message}`;
            logs.appendChild(logEntry);
            logs.scrollTop = logs.scrollHeight;
        }

        function clearLogs() {
            const logs = document.getElementById('logs');
            logs.innerHTML = '<div class="log-entry">üßπ Logs cleared</div>';
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Initialize when page loads
        window.addEventListener('load', async () => {
            logMessage('üé¨ Initializing RxDB NATS Replication Frontend...');
            await initRxDB();
            logMessage('‚úÖ Ready! Click "Start NATS Replication" to begin syncing.');
        });
    </script>
</body>
</html>